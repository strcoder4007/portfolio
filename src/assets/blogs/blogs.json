[
  {
    "title": "Need For Speed Self Driving Car",
    "content": "<h3>Teaching AI to Dominate the Streets: Self-Driving in Need for Speed: Most Wanted</h3>\n\n<p>Hey there, speed demons and AI enthusiasts! It's your boy Mike, back with another crazy deep learning project. Today, we're gonna marry two of my favorite things: artificial intelligence and illegal street racing. That's right, we're teaching an AI to drive in Need for Speed: Most Wanted (2005)!</p>\n\n<p>Before we dive in, huge shoutout to the folks who've already done some groundwork on this. I've been referencing this awesome GitHub repo: <a href=\"https://github.com/strcoder4007/Need-For-Speed-Self-driving\">Need-For-Speed-Self-driving</a>. If you're interested in this kind of stuff, definitely check it out!</p>\n\n<p>Now, buckle up and let's hit the nitrous on this project!</p>\n\n<h2>The Grand Idea</h2>\n<p>So here's the deal: we're going to create an AI that can drive a car in Need for Speed: Most Wanted. We'll use a convolutional neural network (CNN) to process images from the game and output steering commands. It's like teaching a teenager to drive, except our AI can't blame its mistakes on hormones.</p>\n\n<h2>Data Gathering: Playing the Game (Badly)</h2>\n<p>First things first, we need data. And in the world of supervised learning, that means we gotta play the game ourselves. A lot. Here's how I set up the data collection:</p>\n\n<pre><code>import numpy as np\nimport cv2\nimport time\nfrom grabscreen import grab_screen\nfrom getkeys import key_check\nimport os\n\ndef keys_to_output(keys):\n    #[A,W,D]\n    output = [0,0,0]\n    \n    if 'A' in keys:\n        output[0] = 1\n    elif 'D' in keys:\n        output[2] = 1\n    else:\n        output[1] = 1\n    return output\n\nfile_name = 'training_data.npy'\n\nif os.path.isfile(file_name):\n    print('File exists, loading previous data!')\n    training_data = list(np.load(file_name, allow_pickle=True))\nelse:\n    print('File does not exist, starting fresh!')\n    training_data = []\n\ndef main():\n    for i in list(range(4))[::-1]:\n        print(i+1)\n        time.sleep(1)\n\n    paused = False\n    while(True):\n        if not paused:\n            screen = grab_screen(region=(0,40,800,640))\n            last_time = time.time()\n            screen = cv2.cvtColor(screen, cv2.COLOR_BGR2GRAY)\n            screen = cv2.resize(screen, (160,120))\n            keys = key_check()\n            output = keys_to_output(keys)\n            training_data.append([screen,output])\n            \n            if len(training_data) % 1000 == 0:\n                print(len(training_data))\n                np.save(file_name,training_data)\n\n        keys = key_check()\n        if 'T' in keys:\n            if paused:\n                paused = False\n                print('unpaused!')\n                time.sleep(1)\n            else:\n                print('Pausing!')\n                paused = True\n                time.sleep(1)\n\nmain()\n</code></pre>\n\n<p>This script captures the game screen, resizes it, converts it to grayscale, and saves it along with the key presses. I ran this while playing the game for hours. And let me tell you, trying to drive well while also making sure your data collection script isn't crashing is... an experience.</p>\n\n<h2>Preparing the Data: From Pixels to Tensors</h2>\n<p>Once we've got our data, we need to prepare it for our model. Here's how I processed the data:</p>\n\n<pre><code>import numpy as np\nfrom sklearn.model_selection import train_test_split\nimport cv2\n\ndata = np.load('training_data.npy', allow_pickle=True)\n\nX = np.array([i[0] for i in data])\ny = np.array([i[1] for i in data])\n\nX = X.reshape(-1, 120, 160, 1)\nX = X / 255.0  # Normalize pixel values\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)\n\nprint(f\"Training samples: {len(X_train)}\")\nprint(f\"Testing samples: {len(X_test)}\")\n</code></pre>\n\n<h2>The Brain of our Driver: InceptionResNetV2</h2>\n<p>For our model, we're going with the InceptionResNetV2 architecture. It's like giving our AI driver a supercomputer for a brain. Here's how we set it up:</p>\n\n<pre><code>from tensorflow.keras.applications import InceptionResNetV2\nfrom tensorflow.keras.layers import Dense, GlobalAveragePooling2D\nfrom tensorflow.keras.models import Model\n\nbase_model = InceptionResNetV2(weights='imagenet', include_top=False, input_shape=(120, 160, 3))\n\nx = base_model.output\nx = GlobalAveragePooling2D()(x)\nx = Dense(1024, activation='relu')(x)\npredictions = Dense(3, activation='softmax')(x)\n\nmodel = Model(inputs=base_model.input, outputs=predictions)\n\nfor layer in base_model.layers:\n    layer.trainable = False\n\nmodel.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])\n</code></pre>\n\n<h2>Training the Beast: Let the Games Begin!</h2>\n<p>Now it's time to train our model. This is where the magic happens... and where your GPU starts to sweat.</p>\n\n<pre><code>history = model.fit(\n    X_train, y_train,\n    validation_data=(X_test, y_test),\n    epochs=10,\n    batch_size=32\n)\n\nmodel.save('nfs_driver_model.h5')\n</code></pre>\n\n<p>I ran this for about 10 epochs. It took forever, and I'm pretty sure my GPU was plotting revenge against me by the end.</p>\n\n<h2>The Moment of Truth: Testing Our AI Driver</h2>\n<p>After the training, it was time to see if our AI could actually drive without crashing every two seconds. Here's the script I used to test it:</p>\n\n<pre><code>import numpy as np\nfrom grabscreen import grab_screen\nimport cv2\nimport time\nfrom directkeys import PressKey, ReleaseKey, W, A, S, D\nfrom tensorflow.keras.models import load_model\n\nmodel = load_model('nfs_driver_model.h5')\n\ndef straight():\n    PressKey(W)\n    ReleaseKey(A)\n    ReleaseKey(D)\n\ndef left():\n    PressKey(A)\n    ReleaseKey(W)\n    ReleaseKey(D)\n    ReleaseKey(A)\n\ndef right():\n    PressKey(D)\n    ReleaseKey(A)\n    ReleaseKey(W)\n    ReleaseKey(D)\n\ndef main():\n    last_time = time.time()\n    for i in list(range(4))[::-1]:\n        print(i+1)\n        time.sleep(1)\n\n    paused = False\n    while(True):\n        if not paused:\n            screen = grab_screen(region=(0,40,800,640))\n            print('loop took {} seconds'.format(time.time()-last_time))\n            last_time = time.time()\n            screen = cv2.cvtColor(screen, cv2.COLOR_BGR2GRAY)\n            screen = cv2.resize(screen, (160,120))\n\n            prediction = model.predict([screen.reshape(-1,120,160,1)])[0]\nmoves = list(np.around(prediction))\n            print(moves, prediction)\n\n            if moves == [1,0,0]:\n                left()\n            elif moves == [0,1,0]:\n                straight()\n            elif moves == [0,0,1]:\n                right()\n\n        keys = key_check()\n\n        if 'T' in keys:\n            if paused:\n                paused = False\n                time.sleep(1)\n            else:\n                paused = True\n                ReleaseKey(A)\n                ReleaseKey(W)\n                ReleaseKey(D)\n                time.sleep(1)\n\nmain()\n</code></pre>\n\n<h2>The Good, The Bad, and The \"How Did It End Up There?!\"</h2>\n<p>Now, I'd love to tell you that my AI immediately started driving like Vin Diesel in The Fast and the Furious. But let's be real, this is machine learning we're talking about. Here are some of the speed bumps I hit along the way:</p>\n\n<ol>\n    <li><strong>Data Imbalance</strong>: Turns out, I'm a boring driver. Most of my training data was just driving straight. The AI learned this really well and would often just plow straight into walls. I had to intentionally oversample turns to balance things out.</li>\n    <li><strong>Overfitting</strong>: At one point, my AI got really good at driving on one particular track... and absolutely terrible everywhere else. It was like it had memorized that one route and forgot how to actually drive.</li>\n    <li><strong>The \"Indecisive Driver\" Syndrome</strong>: Sometimes, the AI would rapidly switch between turning left and right, making the car wiggle down the road like it had one too many virtual beers. Implementing a small delay between actions helped smooth this out.</li>\n    <li><strong>Performance Issues</strong>: Running the game, screen capture, and neural network inference all at once was... challenging. My poor laptop sounded like it was trying to achieve liftoff. I had to optimize my code and lower the game's graphics settings to get everything running smoothly.</li>\n    <li><strong>The \"Ghost Driver\" Bug</strong>: There was a period where my AI would sometimes just... stop. The car would coast to a halt and sit there, completely unresponsive. Turned out to be a sneaky bug in my key press simulation code.</li>\n    <li><strong>Unexpected Obstacles</strong>: The AI did great on empty roads, but throw in some traffic or cops, and it was mayhem. Teaching it to handle dynamic obstacles is a whole other challenge I'm still working on.</li>\n</ol>\n\n<h2>What's Next? More Power!</h2>\n<p>So, where do we go from here? Well, there's still a lot to improve:</p>\n\n<ol>\n    <li><strong>More Data</strong>: Always more data. I'm thinking of setting up a rig to automatically gather training data while I sleep. Who needs rest when you can have your computer play video games for you?</li>\n    <li><strong>Dynamic Obstacle Handling</strong>: Teaching the AI to deal with other cars, cops, and maybe even those pesky pedestrians who always seem to jump in front of you at the worst times.</li>\n    <li><strong>Speed Control</strong>: Right now, our AI is basically a lead-foot driver always flooring it. Teaching it when to slow down could be interesting.</li>\n    <li><strong>Multi-Task Learning</strong>: Maybe we could teach it not just to drive, but to complete races or evade cops. Now that would be cool!</li>\n</ol>\n\n<h2>Wrapping Up</h2>\n<p>And there you have it, folks! We've taken our first steps into teaching an AI to be a street racer. It's been a wild ride, full of crashes (both in-game and code), late nights, and more energy drinks than I care to admit.</p>\n\n<p>Remember, the code in this blog is just a starting point. There's a ton of room for optimization and improvement. Feel free to take this idea and run with it! And if you make any cool improvements, let me know. I'm always down to see some AI street racing action.</p>\n\n<p>Until next time, keep your code clean and your nitrous tanks full!</p></p>",
    "time": "18 July 2024",
    "tags": ["Need For Speed", "Deep learning", "Convolutional Neural Networks"]
  },
  {
    "title": "Mario Reinforcement Learning",
    "content": "<h3>Adventures in Plumbing: Teaching an AI to Play Super Mario Bros</h3>\n\n<p>Hey there, fellow code wranglers! Felt like it's time to start another deep learning adventure. Today, we're diving into the world of reinforcement learning by teaching an AI agent to play everyone's favorite Italian plumber: Super Mario Bros!</p>\n\n<h2>The Big Idea</h2>\n\n<p>So, here's the deal: we're going to create an AI that learns to play Super Mario Bros through trial and error. It's gonna be like watching a toddler learn to walk, except with more fire flowers and fewer tears (hopefully).</p>\n\n<h2>Setting Up the Environment</h2>\n\n<p>First things first, we need to set up our environment. We'll be using OpenAI's Gym library along with a custom Mario environment. Here's how we get started:</p>\n\n<pre><code>import gym\nimport gym_super_mario_bros\nfrom gym_super_mario_bros.actions import SIMPLE_MOVEMENT\nfrom nes_py.wrappers import JoypadSpace\n\n# Set up the Mario environment\nenv = gym_super_mario_bros.make('SuperMarioBros-v0')\nenv = JoypadSpace(env, SIMPLE_MOVEMENT)\n\n# Define the state space and action space\nstate_space = env.observation_space.shape[0]\naction_space = env.action_space.n\n\nprint(f&quot;State space: {state_space}&quot;)\nprint(f&quot;Action space: {action_space}&quot;)\n</code></pre>\n\n<h2>Building the Brain</h2>\n\n<p>Now that we've got our playground set up, it's time to build our Mario's brain. We'll use a deep Q-network (DQN) for this. Here's a simple implementation using PyTorch:</p>\n\n<pre><code>import torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport numpy as np\n\nclass MarioBrain(nn.Module):\n    def __init__(self, state_space, action_space):\n        super(MarioBrain, self).__init__()\n        self.fc1 = nn.Linear(state_space, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, action_space)\n\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        return self.fc3(x)\n\n# Initialize our brain\nmario_brain = MarioBrain(state_space, action_space)\noptimizer = optim.Adam(mario_brain.parameters(), lr=0.001)\nloss_fn = nn.MSELoss()\n</code></pre>\n\n<h2>Training Loop</h2>\n\n<p>Alright, now for the meat and potatoes of our project: the training loop. This is where Mario will learn to dodge goombas and collect coins like a pro.</p>\n\n<pre><code>def train_mario(num_episodes=1000, epsilon_start=1.0, epsilon_end=0.01, epsilon_decay=0.995):\n    epsilon = epsilon_start\n    for episode in range(num_episodes):\n        state = env.reset()\n        total_reward = 0\n        done = False\n\n        while not done:\n            if np.random.random() &lt; epsilon:\n                action = env.action_space.sample()  # Explore\n            else:\n                q_values = mario_brain(torch.FloatTensor(state))\n                action = torch.argmax(q_values).item()  # Exploit\n\n            next_state, reward, done, _ = env.step(action)\n            total_reward += reward\n\n            # Train the network\n            q_values = mario_brain(torch.FloatTensor(state))\n            next_q_values = mario_brain(torch.FloatTensor(next_state))\n            target = reward + 0.99 * torch.max(next_q_values)\n            loss = loss_fn(q_values[action], target)\n\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n            state = next_state\n\n        epsilon = max(epsilon_end, epsilon * epsilon_decay)\n        print(f&quot;Episode {episode + 1}, Total Reward: {total_reward}, Epsilon: {epsilon:.2f}&quot;)\n\n# Let's train our Mario!\ntrain_mario()\n</code></pre>\n\n<h2>The Good, The Bad, and The Ugly</h2>\n\n<p>Now, I'd love to tell you that everything went smoothly and Mario instantly became a speedrunning champion. But let's be real, this is machine learning we're talking about. Here are some of the hurdles I faced:</p>\n\n<ol>\n    <li><strong>The Curse of Sparse Rewards</strong>: Mario games are notorious for having sparse rewards. Our little plumber might go a long time without getting any positive feedback, which makes learning tough. I had to experiment with reward shaping to give more frequent signals.</li>\n    <li><strong>State Representation Woes</strong>: Initially, I tried using raw pixel data as input. Big mistake. The state space was enormous, and training took forever. I ended up using a more compact representation of Mario's position, velocity, and nearby obstacles.</li>\n    <li><strong>Hyperparameter Hell</strong>: Choosing the right learning rate, discount factor, and exploration rate was like trying to find the right combination on a lock with a million digits. I spent more time tuning hyperparameters than I'd like to admit.</li>\n    <li><strong>The \"Mario is Drunk\" Phase</strong>: In the early stages of training, watching Mario play was hilarious and frustrating in equal measure. He'd run straight into the first goomba, or worse, just dance back and forth without making any progress. Patience is key, folks!</li>\n    <li><strong>Memory Issues</strong>: As the replay buffer grew, my poor laptop started to wheeze like an asthmatic Koopa Troopa. I had to implement a more efficient memory management system to keep things running smoothly.</li>\n</ol>\n\n<h2>Wrapping Up</h2>\n\n<p>After many late nights fueled by energy drinks and pizza (very Mario-appropriate, I might add), our AI finally started to show some promise. It's not beating any world records yet, but it can consistently make it through the first level without falling into pits or hugging goombas.</p>\n\n<p>Here's a quick snippet to see our trained Mario in action:</p>\n\n<pre><code>def watch_mario_play(num_episodes=5):\n    for episode in range(num_episodes):\n        state = env.reset()\n        done = False\n        total_reward = 0\n\n        while not done:\n            env.render()  # This lets us watch Mario play\n            q_values = mario_brain(torch.FloatTensor(state))\n            action = torch.argmax(q_values).item()\n            state, reward, done, _ = env.step(action)\n            total_reward += reward\n\n        print(f&quot;Episode {episode + 1} finished with reward: {total_reward}&quot;)\n\n    env.close()\n\nwatch_mario_play()\n</code></pre>\n\n<p>And there you have it, folks! We've taken our first steps into the world of reinforcement learning with Super Mario Bros. It's been a wild ride, full of frustration, excitement, and more than a few facepalm moments. But hey, that's the joy of machine learning, right?</p>\n\n<p>Next time, I'm thinking of tackling NFS Most Wanted. How hard could it be to teach an AI to self drive?</p>\n\n<p>Until then, keep coding and may your training losses always converge!</p>",
    "time": "10 July 2024",
    "tags": ["mario", "reinforcement learning"]
  },
  {
    "title": "The Essence of Engineering",
    "content": "<p>I have been programming for the past six years—two and a half years in competitive programming and the rest in web development. While competitive programming felt like true engineering, web development, especially frontend, does not. Six years in, I aspire to be an engineer in the truest sense. As people venture to Mars, I'm here centering text in a div. Both are labeled \"Engineering,\" but how can I equate my work to theirs? The difference in impact, skill, and excitement is stark, making me question if I'm truly utilizing my potential. No matter how proficient I become in web development, I'll always feel my mind could be better applied to System Engineering or Machine Learning, tackling the truly challenging problems. Web development may seem filled with unsolvable tasks, but I disagree. At best, it's about novel ideas and doing something new within the browser.</p><p>At the end of the day, coding for the web isn't the bottleneck; it's the idea. Startups thrive on new ideas rather than groundbreaking technology. Innovation in web development is driven by necessity, while fields like machine learning, as of early 2020, still have vast uncharted territories, offering ample room for innovation and new, once-unimaginable ideas. In web development, the outcome is often clear, whereas in fields like AI, the potential is still largely unknown. During my time in web development, I realized I was coding, not programming. I aspire to be a far better programmer, not just a coder. It's time to move beyond the browser and into the real world of engineering.</p><p>I know this might sound like I'm disparaging web development, but I'm not. To each their own. I appreciate web development for what it is. The challenge lies in its complexity, not in its difficulty. It's harder to maintain the big picture as it gets complex, but it follows a set flow and predefined rules, even in backend development. I still enjoy web development at my job. It's not difficult, so I set myself ambitious deadlines to recapture the thrill I felt during competitive programming. Though web development is fun, lucrative, and useful, I don't see it as prestigious. System engineering, machine learning, and solving the unsolvable seem more prestigious to me, perhaps because fewer people venture into those realms.</p><p>With confidence in my technical skills and a couple of unique ideas, I believe I can achieve great things. To me, engineering isn't about replicating well-trodden paths (like web development). True engineering is a way of thinking: compartmentalizing, filtering out the noise, distinguishing between noise and gold, simplifying problems to comprehensible dimensions (mathematics), building on past achievements, viewing problems from multiple perspectives, and leveraging human research across various fields to create seamless solutions. That's what I believe true engineering is.</p>",
    "time": "25 February 2020",
    "tags": ["machine learning"]
  },
  {
    "title": "Pattern Recognition: What's next in tech?",
    "content": "<h3>Humble beginnings: The age of digitization</h3><p>First when computers came to be in 1960s and 70s, they where only used by scientists and the tech savy. It was obvious to the inventors that the real application of this invention is not in scientific research but in the hands of general public. Entrepreneurs like Bill Gates and Steve Jobs(visionary but still, fuck him) among others were the first to realize this, hence putting all their efforts in making computer accessible to the general public for personal use leading to the foundation of Microsoft and Apple. And they where right! Hence, the explosion of applications of computer in every field that existed. Shreading old methods and making everything digital. <b>It was the inventors who started this revolution but, it was the general public who carried this invention to unimaginable heights.</b></p><h3>Pattern in the age of globalization</h3><p>Then in 1980s and 1990s a new invention leveraging computers came to be: The internet. At first it was used only for research and military purposes. But the inventor Tim Berners Lee and his team knew the real power of internet can only be attained when made global, internet was made keeping that in mind but only for Government network at that time. So, on 6th August 1991 internet was opened to the public FOR FREE. All of a sudden an explosion of internet startups occured, hiding away another level of abstraction and making it even easier for general public to use it by creating tools such as internet browser. This revolution was much greater and longer than the previous because it allowed people to connect to each other all around the planet. It served as a precursor, a base on which the age of information was yet to establish itself. <b>Again, the revolution was started by the inventor but it was the general public who carried it through and made the invention what it is right now.</b></p><h3>Pattern in the age of information</h3><p>The mid 1990s but mostly 2000s saw the rise of social networking sites leveraging internet. This started with the invention of Geocities(1994) and AOL instant messenger(1997) where information could be sent and received from anywhere on the planet in miliseconds. The potential of these inventions easily surpassed old methods such as landline, newspaper and the way people connect with each other. This led to another revolution: The fifth estate. Everything could be found on the internet and general public would themself upload their information on the internet. <b>New inventions were made on top of previous inventions(computer, internet) but, it was again the general public driving the revolution.</b></p><h3>Pattern in the age of automation</h3><p>Started mostly in 2010s meaning we are currently living in the age of automation. The age of information generated(and is still generating) unfathomable amount of data every day which lead to the age of automation. Hence, the next big thing: Artificial Intelligence was born (technically, it was born in 1950s but back then we neither had data nor fast enough hardware to process any meaning out of it.) Again, tools were invented by the visionaries who predicted the changing market, social and economic needs. Using the tools countless applications of AI came into existence. <b>The contribution of general public in this age is their data hence, it's again the general public who's responsible for driving the revolution.</b></p><h3>The future: Man and machine as one.</h3><p>The pattern I see everytime is that, <b>at first a technology is invented, then a platform is created by the early ones, the visionaries who realize it's potential, then it's let loose to the general public to leverage that technology and the explosion occurs.</b> One can argue that in the age of automation general public is not directly influencing the revolution. Data is key to automation and that data is produced by general public but still, they are not the ones processing the data, it's the Data Scientists. And I think this argument is correct. It's like Youtube has been invented but, only Youtube employees can upload video. That's the state of AI right now. It needs general public to explode, just like in the case of Youtube, Instagram, Medium etc. But, the age of automation hasn't ended yet.</p><p>And that's the thing I'm trying to figure out before switching from Software Engineer to Machine Learning Engineer. How can one give the power of AI in the hands of general public such that they can implement it the way they want. That would be this age's revolution. AI explosion hasn't happened yet because the power of AI is still in the hands of visionaries and the tech savy. It hasn't yet trickled down to the general public, who matters the most.</p>",
    "time": "14 April 2019",
    "tags": ["pattern", "2019-2025", "Industry 5.0"]
  },
  {
    "title": "Project Updates",
    "content": "<p>I might need to change to my own AWS instance and therefore will have to shift all my projects to the new one. This is a good time to update some of my projects. I've been meaning to update them and add new features which I'll enumerate below for each of them. Some projects have proved themselves to be very useful and I find myself using them all the time over the past year. I'm also going to update CSS libraries, frameworks, their CLIs, npm (thinking about switching to yarn) and node to their latest version and try to make each app as progressive as possible.</p><h3>Project#15: Empire of the clouds (ReactJS)</h3><p>This is the most postponed project ever and can't be postponed anymore, I urgently need a universal app for music streaming and organization i.e, it should run on every device and always be ready with my updated library <strong>everywhere automatically</strong>. I need to build a web app that can:</p><ul><li>stream my music files stored on Google Drive</li><li>a web player with amazing UI/UX</li><li>scrobble my track to last.fm</li><li>very lightweight hence, reactjs</li></ul><h3>Time my Show update (Angular 7 + Apollo + GraphQL)</h3><p><a href=\"http://shubhamswe.xyz/tms\" target=\"_blank\">Time my Show</a> works but it's not built good enough to be used every day as I didn't give much time to this project when I wrote it. In the past year it has proven it's utility. Therefore, it needs improvements and bug fixings! <a href=\"https://github.com/strcoder4007/timeMyShow\" target=\"_blank\">Github repo</a><br />I need:</p><ul><li>graphql for all APIs</li><li>to show the number of seasons and number of episodes in the season as well.</li><li>to fix routing.</li><li>to add some kind of Indicator to hint typing in the banner.</li><li>to implement database possibly postgresql or mongodb.</li><li>sorted new episodes on top</li><li>to update to Angular 7</li></ul><h3>Memory Sequence update (Angular 7 + MongoDB)</h3><p>This very project needs an update. It has been the most useful project yet. I use it almost every day. I have a list of ideas that I have accumulated over the last year that I want to implement in this project. <a href=\"https://github.com/strcoder4007/memorySequence\" target=\"_blank\">Github repo</a><br />I need:</p><ul><li>font options</li><li>writing stats</li><li>to make it completely progressive</li><li>remember and quotes section</li><li>categories (Programming, Philosophy/Psychology, Books, Music, Skateboarding, Writing stats.)</li><li>to make every paragraph admin/public possible + segmented loading (mongoDB)</li><li>automate to correct spellings (maybe)</li><li>mobileUI/UX</li><li>fucking Routing (ExpressJS)</li><li>update to Angular 7</li><li>implement editor to write blogs on website itself</li></ul><h3>Town Center update (Angular 7)</h3><p><a href=\"http://shubhamswe.xyz\" target=\"_blank\">Town Center</a> is the website to showcase all my projects, competitive programming stats. I made this project to prove to myself that I can make a responsive web app without any CSS library. It came out fine but with a LOT of code mostly media queries but on resolutions such as 1440x900 and 1600x900 it doesn't look symmetrical and it's a shame that my web app is not even symmetrical. <a href=\"https://github.com/strcoder4007/theTownCenter\" target=\"_blank\">Github repo</a><br />Hence, I need:</p><ul><li>to rewrite the whole css using Bootstrap or Bulma (using library is better for future maintenance)</li><li>more transparency</li><li>update to Angular 7</li></ul><h3>Project#19: Creek (Apollo + GraphQL)</h3><p>I left this project last year because I was using REST APIs and first making calls for enumerating favorite artists then again making calls for each of their albums and then sorting chronologically to see if any new album has been released. This was costing me around 20 seconds for making all the calls. Rendering the app totally unusable. Hopefully, I'll find a way out of this by using GraphQL or using some other api source altogether. I made it in Angular 5, if it comes down to making the app from scratch (which I'm hoping) I'll use React this time otherwise still I'll update it to Angular 7. <a href=\"https://github.com/strcoder4007/creek\" target=\"_blank\">Github repo</a></p>",
    "time": "30 December 2018",
    "tags": ["pet projects", "still 2018"]
  },
  {
    "title": "About",
    "content": "<p><em>As the clock struck</em> <em>midnight</em>, I was cozily nestled into my blanket, sitting upright in the corner of my room, listening to Red Hot Chili Peppers. I realized it was New Year’s when the celebratory sounds reached my ears. The sense of new beginnings had lifted my spirits. I hoped this year would be my chance to rekindle my passion and return to Competitive Programming, practicing with even more dedication than I had in the latter half of 2015. I found myself contemplating New Year's resolutions—a concept I usually dismissed, having failed at them countless times before. However, that night, swept away by the forgiving sense of new beginnings, I decided to give it another try. Unsurprisingly, I didn’t succeed, but that’s a story for another time.</p><p>Among my resolutions was the intention to better document my life. I felt overwhelmed by the multitude of memories I struggled to retain. I often forgot them if I didn't revisit them regularly. This notion, as it turns out, is supported by science. I devised a plan to improve my documentation, although I was unsure of the best approach. My music history was being recorded by last.fm, an important aspect of my documentation. Equally important was capturing memories as stories. This blog fulfills that purpose. I’ve named it <em>Memory Sequences</em>, a nod to the video game franchise <em>Assassin's Creed</em>. I began creating this website on July 21, 2017, and documented the development process throughout that week. Consequently, those initial blogs will be the first entries on the site. However, I’ll also be sharing memories from before the website's inception, making these stories technically older than the earliest blogs. I’ve decided to arrange the blogs chronologically, with this entry serving as an introduction to the website’s purpose and origins.</p><p>This website is designed to help me document my life more effectively. Therefore, the content posted here is primarily intended for <em>future me</em>, which means that many of the gory details and secrets will be included. However, I’ve made it accessible to anyone interested. As for the types of blogs I’ll be posting—they’re quite straightforward. I will share anything that holds significance for me or for which I feel gratitude, focusing on three main areas: music, philosophical insights, and personal memories. Additionally, I’ll cover topics such as skateboarding, books, and computer science.</p>",
    "time": "12 May 2017",
    "tags": ["about", "new year", "resolution", "2017"]
  },
  {
    "content": "<p>I was trying to embed spotify player in memories. It's a great idea. I should play with spotify and last.fm apis, there could easily be some features I don't know about. Well, I looked through their apis, nothing interesting to use on this website.</p><p>Listen to this song...</p><div class=\"col-md-6 col-sm-12\"><iframe src=\"https://embed.spotify.com/?uri=spotify%3Atrack%3A6ppPNxdwG8A5Ed8DlNLV6I\" width=\"100%\" height=\"80\" frameborder=\"0\" allowtransparency=\"true\"></iframe></div><p>I accidentally listened to this when Spotify played this after <em>Iron Maiden's</em> playlist finished. Fell in love the moment I heard it. Althought in my experience the songs that I like in the first listen are the songs which seem to fade away quickly. </p><p>Anyways, I am using tinyMCE&nbsp;editor. It's nice because it's producing the final HTML in minified format. I just need a way to automate this process. I should look into the features of this editor. Maybe there's a way to convert the HTML into JSON&nbsp;somehow. That would be so easy for me then. Will have to write extra code for user layer for login, that would require me to study MongoDB. Well, let's see how this goes.</p><p>I got an idea, some implementation of adding notes to memories. Although it would require me to manually add them in data.json file which will be tiresome. We will see about that. I have decided to leave data.json to be my primary and quite frankly the only way to update/add memories. I just need to figure out AWS. It's so fucking confusing. I configured it to run blue/green deployment but my server where not stopping, even when I terminated them manually, new servers kept popping up!</p><p>And this is the reason why you should plan your project properly before starting it. I don't have continous integration or any server to put this project on or the final wireframe of the project. When they say that you should wireframe your project first, I hope they know that most probably there will be major changes to the project in the future. I should have wireframed properly eitherways. Now I need to shift everything from base component to a new component of itself such that I can summon it anywhere in the base component as a part of the it. And similarly make new components as a child of the base component. If I had thought about this earlier then it would have saved much of my time now. So, I guess wireframing is important even though you will have to change most of it in the end.</p>",
    "tags": ["computer science", "development", "dio", "wireframe"],
    "time": "28 July 2017",
    "title": "MS#03: Building the website: Wireframing?"
  },
  {
    "content": "<p>I want to write about the project as I don't have any strong feeling towards something or any other substancial thing to write about.I have been working on this project for 12 days now. I am happy with what I've built so far. Angular 4 is an awesome framework! It has made the webapp so modular and versatile that each component can co-exist with every other component and together they are forming different states which basically is one of the permutation states. The app seems to run fast and efficient as I don't have any additional modules and libraries lying around. Dead-code has been minimized although Angular 4's <em>tree-shaking</em> would <em>nail the coffin</em>. The aim was to be light-weight, there was no restrictions on the processing power or anything, I made it such, 'cause <em>why not</em>? Although according to <em>Chrome's</em> console the whole app takes 2.3 seconds to load, which is higher than expected. So, I tried running a new project generated via angular-cli and benchmark it. It was taking 1.6 seconds to load the complete seed project. According to that I guess my app is supposed to take 2.3 seconds. I think <em>Spotify</em> is delaying the app. I see the errors for every <em>Spotify</em> player embedded, in the console. Strangers on the Internet are saying that it's some <em>Google Chrome</em> SSL certificate permission termination error. The solution provided didn't worked.</p><p>The webapp is more or less completed, the only things left is the admin layer and search linking. I have found the solution as to how I can make this webapp public and at the same time use it the way I wanted. The idea is to add an admin layer such that all the memories with \"personal\" tag on them will only be shown to me. These personal memories will simply be excluded from the final public JSON object. I will code it tomorrow I guess. The next problem would be to rent a Virtual Private Server. I am afraid in using my Dad's card for paying on services which automatically charge you after your free subscription gets over. I am very lazy and careless at this. I need a company where it's paid monthly or completly free, although the later is hard to find. It just happened to me the other day, I rented a VPS from <em>Amazon</em> and it was fine and working, I even checked <em>blue/green deployment</em>, it all worked. After getting bored off playing with it, I went on to some other project. Four days later, I found, while I was messing with AWS I started four instances and all of them have been continuously running since. The free(which is $1) limit was 750hrs and I was doing 940hrs.</p><p>Tomorrow I definitely will score a server. I hope Digital Ocean has <em>Continuous Integration</em>. If I am able to deploy it and pipe it to Github, I can automate the process of updating the content on the website.</p>",
    "tags": ["computer science", "development", "web app update"],
    "time": "2 August 2017",
    "title": "MS#04: Web App Update"
  },
  {
    "content": "I can write about it but what's the fucking point?",
    "tags": ["nihilism", "philosophy", "the truth"],
    "time": "4 August 2017",
    "title": "Nihilism"
  },
  {
    "content": "<p>Memory Sequences is almost complete, one more day might do it. I am currently well-versed in Angular4 + Typescript and I have 3 more web apps to make using this framework which is good but I want to make apps using GoLang&nbsp;and Ionic Framework as well. I am thinking of giving ReactJs a run too. People are saying it's light-weight and easy to learn. It's going head-to-head against Angular4, it has to be good. But then I also want to explore&nbsp;C++'s development side by making a project. And if I'm doing C++ then I might as well make games. That would check another thing off the bucket-list. Although&nbsp;I want to get in machine learning too, I've never paid much attention to it in the past but it seems that's where the future's headed. That makes 5 completely(more or less) new domains to be learned by me in the next 9 months. It would feel overwhelming if I make a schedule to do all these projects. Schedules never work with me any ways. I'm not going to stress over completing all of these but right now I want to do something new and that's why I need to decide on something soon.</p><p>\"<em><strong>Hofstadter's Law:</strong> It always takes longer than you expect, <br />even when you take into account Hofstadter's Law</em>.\"&nbsp;&mdash;&nbsp;Douglas Hofstadter</p><p>It is probable that I won't complete all of these in time so, I have decided to divide them on the basis of urgency of the projects a&nbsp;short-term goal and a long-term goal. Skills in short-term goal are those which I need for mediocre jobs most probably in a start-up, keeping myself on the forefront of technology will help here. For completing short-term goals I think I should continue doing web dev and try learning the obscure parts such as RxJs, ReactJs, make software I need to automate my life thus, encouraging my sloth behavior and eventually taking me to the next level of laziness. Similarly for long-term goal i.e aiming for a job in really good startup most probably abroad. Getting sponsored for a visa is getting harder, although it's relatively easier for developers. Some European countries have a special job skills which a migrant can have, fortunately, software engineering related skills are the ones most in demand. For these startups and companies, I will require having a wider knowledge in computer science. I come from an algorithm(C++) background so I can say a huge &amp; a fairly difficult part is already covered. Game development in C++ would teach me the other side of the language the Object Oriented Programming side. I need to learn machine learning as well. It seems really fun. Actually, I don't know shit about machine learning, I ain't got anything else to write about it other than that the projects are in a different dimension and I really want to try it. I think all this would enstate me as a programmer with fairly balanced knowledge in computer science. According to me and quote me on this, \"becoming a jack of all trades and master of none seems fruitful in software development.\"</p><p>I was of bored of programming so I decided to think and write about the technologies I should learn next. Making plans is so stupid but I still did it. Just like millions times before this plan will also fail, I will complete them if they stay fun otherwise I will give up, I'm not going to stress over them. Actually you can't call this a full-fledged plan. There's a deadline but I won't care much if I crossed it and I haven't even decided the order of the project. I just wanted to layout my interests and decide which one to do first.</p>",
    "tags": ["computer science", "development"],
    "time": "7 August 2017",
    "title": "MS#05: Do or do not, there is no try"
  },
  {
    "content": "<p>This past week my writing has been to a minimum. I don't exactly know why. Is it because of the website? Because I am not comfortable enough with the security of my personal blogs? Or is it because writing on a keyboard hasn't yet made itself completely familiar to me? Most probably it's nothing, it was like this because I didn't make the personal filter and because of that storing the data was time-takingly painful. I am again headed to the place where I was headed back in May. The funny thing is that it made the <em>new me</em> (I know these words have a touch of naiveness and are filled with ego but I can't think of any replacement right now) scared for a moment. I think much more is going on than I know, psychologically speaking. Fuck this! I'm not gonna care if these logs are poorly written.</p><p>I should get in a habit of writing my thoughts down before they fly away, I tell you, some of them are amazingly profound that in some sense I know immediately that I won't reach this conclusion ever again in my life, this should be written right now and here! I think my behavior is changing to <em>Hunter S. Thompson's</em>. I am really interested to know more about him as I find him someone that has been to places only few have treaded to. Therefore he would have the answers to my questions. I thought I was done with questions and that's why it's really important to keep in mind that I gave up on trying, I didn't gave up on my interests. It's just a phase I guess, you know, the immitation you do when you are completely polarized by someone. Although I won't mind if I started living on his principles and acting the way he did. Actually that's what I want, this is the first time I've found a balance between programming and drugs. A balance which still needs improvement but a working one nonetheless. Living on Hunter S. Thompson's principles would actually make me better at my craft. He is one of the <em>interesting people</em> I will write about soon. I just realized the title of this blog is \"Life Update\" and I haven't written shit on it yet. Programming is going slow these days. I am not able to write enough code these days because this weed is making me such a sloth. I don't feel like programming because of it. Even the aim of the day is not a lucrative one&mdash;<em>fix the login layer and try to find a way to map tags to searched string</em>. I want something more interesting than this. Actually these objectives mark the end of the project. I guess what's going on is my ignorance towards <em>almost</em> completed jobs. I do this when the job is more or less completed (but still incomplete) to the point where it can be practically said that it's completed. There's a model which is up and running in all it's glory but the luxury features are pending. The problem with this is that I leave the job incomplete and when I need them in future to show or use it in another project, I will have to complete it, but by then the technology in which it's written would have already aged like a motherfucker and I won't have any choice other than setting the project aside. I don't care much if I set myself straight but I recommend I should, it will save a lot of time in the future. I should start something hard. Game programming I guess. I want to be sober now. I want my brain to function normally. I want to feel the high of making new shit, music and writing. I need to get out of this room more frequently. College could be an option, there's food too. Well, it's only 4hrs, it can be done.</p><p>I need to write about the whole giving up thing. After I gave up pretty much everything inside my head changed. I keep thinking about a topic to write about, a topic which I have already written in the notebooks. But, whatever's there in the notebook is pre-giving up. So most of the things I wrote are the things I don't believe in now. I guess I should exclude everything pre-giving up. But to think&mdash;\"not logging most of my mistakes could be a mistake\" is something I can't overlook. I guess I will be adding few older blogs here and there afterall!</p>",
    "tags": ["life update", "Hunter S. Thompson"],
    "time": "8 August 2017",
    "title": "MS#06: Life Update"
  },
  {
    "content": "<p>I've started building the next project, \"Empire of the clouds\", I named it after one of the most iconic song from Iron Maiden, an absolute eighteen minute marvel. The song is about the legendary airship R101, I went with this name because this webapp is music based and the whole point of this webapp is to store everything on the cloud, considering my music collection an <em>empire</em>. Anyways, I'm writing in typescript and using angular 4, for the last time I swear. Actually, I guess I will make one desktop app for windows and Linux using angular 4, nodejs and electron.</p><p>I am so psyched to start making this one. I'm finally doing something for improving my music library's accessibility and portability. I'm curently listening to non-metal songs on a webapp made by some young programmer. I feel such freedom using this app. All I need is internet and my google drive password and I'll have access to my music. My carefully hand-picked music and playlists all in 320kbps. Time and again I am forgetting where the music is playing from. When I'm realizing it's from the webapp, and that there's no relation to local storage or this computer, it's making me feel so secure and free.</p><p>I've wireframed the app and written all the features I need in two parts: essential and luxury features. It would be hard to build this one. I don't know most of the concepts this app would require. </p><img style=\"padding: 10px 0px\" src = 'https://hmu6bg.bn1301.livefilestore.com/y4mZOoLRylqNFJoe-4ilheJJltn-DXvicuOeM0irpTnZNyzDAEBO-i859v67wfxE3dPIW3rnmg2oy33RlrOGQMzbyqYDRv_Rejla0whrqoNI9Inw6Np4UDZYhUlW2-E_f70VqGm0ppo7kZ8MT8k6pE5_nknSUCyYe1yCyQJdxskc6lkf1Z_EozWwZDdfqIfiOg67rQ81Qim8F1Kz5WhzovvfQ?width=1024&height=765&cropmode=none' width='100%'><p>Well, I made Memory Sequence in angular 4 and typescript when not knowing shit about them. Making this one requires really good knowledge of the framework. I don't know if I will be able to complete it but I will try. </p><p>The webapp I'm using is doing it's job fine but I need way more features. I want to custom make the software for myself. Make it work exactly the way I want and when I want. Also this app doesn't feel my type, there's no surprise and the design is crappy. I won't feel complete freedom unless I use the things I wrote and can control. I am thinking of parsing artist data from last.fm rather than linking to last.fm's page. This would make it lengthy but better.</p><p>In a nutshell I just need to implement Google auth and then further figure out the api to implement drive methods, once able to receive from drive I need to make a player and search for how to play audio using typescript then I will have to make the directory in tree structure in the sidebar so that I can drag and drop the artist I want to play and btw I need to implement drag and drop too, once the player is running using the songs from google drive I need to implement last.fm apis and make pages for artists i.e content, inside content component 3 types of pages would open song list, artist info and last.fm stats for the artist and last but surely not the least, completely redesign the app for mobile because it needs to look completely different and auto-responsiveness won't work.</p><p>And if I want luxury features too, then add yet another paragraph like that.</p>",
    "tags": ["web dev", "empire of the clouds", "computer science"],
    "time": "27 August 2017",
    "title": "Project#15: Empire of the clouds"
  },
  {
    "content": "<p>So, you know the truth right? That everything is pointless, that we don't matter, that nothing anyone has ever done matters. And nothing lasts forever so, one day our race will perish and the universe would go on like nothing happened. Actually for universe our extinction literally won't matter. Humans have the tendency to romaticize themselves as important beings, that there's purpose to our lives, that we're born for a reason. Nobody is born for any fucking reason. Humans are the same as other animals and plants. It's just that we have a more developed (yet flawed) brain. We are all programmed by our culture to believe that every single child is important and special. The fact that everyone is important directly means nobody is important is completely oblivious to people, I don't know how. I am talking about the sense of self-importance. I said \"sense\" because it's so deeply entrenced in us that we might as well consider it a sense now. It creeps up on you when it's receptors get ego hurt. Just like any other animal or plant, we don't matter either, no matter how developed our brains are we are not fucking special. We got intelligence and through that technology, we can escape our demise, you say? Our species won't be able to answer the identity of the universe ever. We won't ever reach that far.</p><p>\"Eternal blackness beyond the stars<br>we think our wisdom won't get that far\" &mdash; <strong>Iron Maiden, If Eternity Should Fail</strong></p><p>I think I've figured why no one's addressing the elephant in the room and still looking for answers to our existence from souls and spirits. The very nature of human is figuring out the reason behind any cause. We always look for answers and try to figure out the reason, in each and everything. While the whole point of our existence doesn't have any reason other than that a meteorite hit the earth hence commencing evolution. We started fanticizing about souls and spirits and I guess that's how religion was born. Some clever dude figured out the emotional longings of human, the crave for closure and control and fed us lies, about god, that there is a greater being watching over us, that he cares about us, that we are all his children thus, exploiting our weakness, self-importance. This lie was gullable for humans. I guess that's why religion is so prominent, it makes each one of us feel special in the eye of god.<p>\"The pestilence of Jesus Christ<br>There never was a sacrifice<br>No man who hung the crucifix<br>Beware the call for purity<br>Infections their facility<br>I've made my choice, 666!\" &mdash; <strong>Slayer, Cult</strong></p>But humans still try to figure out the reason they were born for, their destiny, the grand plan universe had laid out for them. Nobody's finding that shit 'cause it doesn't exist. Humans search for answers while the sheer simplicity of the fact is that there's no explanation, and that drives them insane. It's because they are wired to search and successfully find complete logical answers to make them feel they're in control. That's why I think most people subconsiously neglect the truth and keep themselves seduced by the thing they call \"life\".</p><p>They seem stupid, right? Afterall, they are searching for something that's right in front of them. No, they are actually not stupid at all. Because you see, that's the point of existence, nothing matters! That's our contract with the universe. There's no good, bad, right, wrong, clever, stupid, lie or truth. It's all in our head, hence in our society. The thing we call life is a mere castle in the air, there's absolutely nothing, nothing at all, but us (animals), plants and rocks, whole lotta rocks. And in reality, in the eyes of the universe we are nothing different from those rocks. If the age of the universe was condensed into one year, recorded human history would fit within the very last seconds of 31 December. We are <a href=\"https://www.youtube.com/watch?v=M8V_glRW1hA\" target=\"_blank\" style=\"color: gray\"><u><b>insignificant</b></u></a>.</p><img style=\"padding: 10px 0px\" src = 'https://miro.medium.com/max/1344/1*6MUyun4RqF_97NKD05Hj8g.jpeg' width='100%'><p>\"We were nothing... for a billion years before our time<br>And we will be... nothing more again, for an eternity yet to come\" &mdash; <strong>Woods of Ypres, Death is not an Exit</strong></p><p>So, how do I live? What should I do until the time I've to confront the final truth, death? According to my philosophy, do absolutely anything you want! Do the most insignificant of things, it would be the same as doing the most <em>significant</em> thing you could possibly do. Because you see, nothing matters. There's a sense of freedom you would feel if you understand the philosophy. Because this literally means that you are free! There's freedom associated in knowing that we are powerless against time and universe, we might as well spend our lives doing what we love no matter how insignificant. What I'm implying is do basket weaving, spend major portion of your day weaving, day after day or be a rocket engineer, work for NASA or SpaceX, contribute in making humans interplanetary. Your time is well spent on doing either of those things and both are actually equally significant, insignificant.</p>“Whatever you do in life will be insignificant, but it is very important that you do it.” &mdash; <strong>Mahatma Gandhi</strong>",
    "tags": ["the truth", "philosophy", "freedom"],
    "time": "28 August 2017",
    "title": "The Truth"
  },
  {
    "title": "Project#16: Code Scrapper",
    "content": "<p>I have started with a new project. I need a code downloader for downloading my codes from codeforces and uploading them to github automatically. I'm making this for Linux, Windows and Mac, therefore, I see some future use of this desktop app not only by me but for anyone who want to save their code locally on whichever platform they want. I am using Javascript, nodejs and electron framework for this. </p><p><u>Will build the app and post here simultaneously.</u> <a target=\"_blank\" href='https://github.com/strcoder4007/codeScrapper'><u>Github Repository</u></a></p><h4><u>Day#1</u></h4><p>Wireframing is done. All I need to do now is to learn how to make desktop apps using electron and make it.</p><p>I've been learning this framework for the past hour and have made a useless but working app, successfully running on my 64 bit Arch Linux.</p><p>A little more decisiveness goes a long way. I did the exact opposite. Added bootstrap and then decided to do something new, therefore, instead bootstrap I'm going to use Materialize CSS. It's new and built on top of Angular Material. I thought of using Angular Material 2 directly but it's too early to use that, even the documentation is not yet ready. I've setteled on Materialize CSS. I haven't yet read it's documentation.</p><p>I have to say, Electron is awesome, but it has yet to go far. Many things are just manual, which I think they can automate in future versions making development faster. Electron is pretty straight forward. It uses IPCrenderer (equivalent to @output/@input in Angular 4) for communication between windows (equivalent to components in Angular 4). Basically the communication is the same as in socket.io.</p><p>Went with frameless window for linux and windows. For mac it's native traffic color is used. I am liking Matirialize CSS, it's new and therefore it has an easy grid system and implementing something like blockquotes and truely responsive texts is already built-in. Also, it uses my favourite font&mdash;Roboto as default font. No more <code style=\"background-color: #111\">npm install --save roboto-fontface</code> haha!</p><h4><u>Day#2</u></h4><p>I'm confused with the way electron handles data flow, if it even does or not. Should I just use ReactJs? or Angular4? No, not angular, it will unnecessarily make this project bloated. There is a way in electron I guess, by using sections. The thing is, electron doesn't divide the application into components, like Angular or React. Therefore, without those frameworks implementing this seems hard. I need to add and remove several nodes from DOM at certain states, there seems no feature like this in electron. I will have to use Vanilla Javascript or one of those two.</p><p>Things have started to make sense now.</p><p>Linux version is working fine, windows version is facing issues and no idea about macos version because I'm broke, I got no money to buy a mac. Will have to find some online tool to check macos version.</p><p>Frontend is almost done. How electron handles Inter-process communications is now clear.</p><p>Frustrated, lost 2 hours of code. I packaged the application for windows (.exe setup). It was created in the root folder itself. I was committing the progress on github, forgot that setup files are also present in the root and skipping the setup files for uploading was not declared in .gitignore file. Therefore, it started to upload 70mb of those setup files. Then I cancelled it and declared it in .gitignore and committed again. Didn't work because git had already staged it. I messed up everything and long story short I lost my code. Now I will have to code it again. My mistake.</p><h4><u>Day#3</u></h4><p>Not going to work on this project today, maybe a little bit if I feel like. Today I need to practice algorithms. I need it for an interview couple of days from now.</p><h4><u>Day#4</u></h4><p>Frontend is complete. Had to re-write the lost code. API's are working therefore now I just need to learn how to authenticate using SPOJ's APIs and download the code. Downloading from Codeforces doesn't require me to authenticate.</p><h4><u>Day#5</u></h4><p>The interface is done. The API is working fine. Although, it will take a couple of seconds to download solutions of user with large problem count. I'm making GET requests to the API around 200,000 times whenever the download button is clicked. If anyone has more solutions than that then, my bad. The main code for requests and parsing the \"Accepted\" solutions was fairly small. Written in vanilla JS I was able to place this block of code in the main file itself which electron uses. </p><p>Anyways, the project is almost done. Took around 9 hours to complete without coding the luxury features. This application can be made a lot better but still, a working version is complete and I want to move on to another project.</p>",
    "time": "28 September 2017",
    "tags": ["desktop app", "javascript", "electron", "nodejs", "cs", "web dev"]
  },
  {
    "title": "My contract with competitive programming",
    "content": "<p>As the number of fields in computer science endlessly seem to grow, it's my time to move on. Competitive programming was the first thing I picked up in college. It was recommended to me by my best friend, in 2nd semester. I was learning C from a textbook at that time. I still remember the day I was not able to understand what are test cases and how the program has to be run/submitted on SPOJ. Although, I seriously started with competitive programming 6 months  later. As I didn't had computer science in high school, I had to learn some languages first. I learned C, python and haskell (you can guess how much I know this now) my fresher year. Then came back to competitive programming.</p><p>I don't want to write about my journey here. In short, I practiced around 150 ad-hoc questions on hackerrank and mathematics questions on project euler. Then slowly I went further deep into competitive programming. Starting with codeforces certainly did mark that. Practiced the hardest I had ever on codeforces, more than 500 ad-hoc questions in the span of 4 months including 14 days holidays. How's that for implementation skill? Suddenly I am among the people who know stuff. Focused more on algotithms, learned all graph alorithms, practiced the SPOJ. Then learned more obsecure ones such as fenwick tree, matrix exponentiation and segment trees. Now I am among the good-ish programmers.</p><p>Then came the motivation shift. It was easy to quickly secure the first place in college leaderboard because no one before me took competitive programming seriously. Having the first place on the leaderboard everytime made everyone come after me. Obviously, having 1st place doesn't matter shit. It was the fun, I was after. I explained it to myself, comparing myself to my competitors is worthless. But I couldn't save myself from getting into that loop of hell. My motivation shifted, I no longer pursued fun, I pursued 1st rank. And everything came falling down. I just can't do anything I don't like. My practice became stagnant. Web development was different and new for me. Fast forward a year of constantly starting and leaving competitive programming and without making any progress. I gave up competitive programming. Moved on to web dev.</p><p>After not thinking about competitive programming for 4 months. I've started to feel the same way I used to in 2015. It's fun again. I've given up on trying. Now, I actually don't give a fuck. I can again pursue just fun in competitive programming. So, I've decided to move on to machine learning as I've made a resonable number of projects in web development. And as for competitive programming, I will do it whenever I feel like. I don't have a goal. Therefore, I don't have a strong motivation for improving. If I feel like, I will learn new algorithms as well. Total freedom.</p>",
    "time": "25 October 2017",
    "tags": ["competitive programming"]
  },
  {
    "title": "Project#17: Langref",
    "content": "<p>Don't feel like doing competitive programming or machine learning therefore, building a new app. This app would help learn new languages fast. I am going to use reactjs for this. I am fairly new to reactjs and I don't have any recent projects in reactjs. This is probably the last web dev project I'm going to do.</p><p>This app would compare certain syntaxes of multiple languages side by side so that you can see the syntactic difference. Syntaxes such as if, for, while, foreach, return, function(), arrays, lists, vectors, sets, slicing, string functions etc. I'm a little rusty in reactjs. And as you know in javascript's scene, react would have changed so much since the time I last used it, I rather learn it again. Haven't yet decided on CSS library. Just checked, bootstrap 4 is out now. I am gonna use that. Will use nodejs, npm is good, don't to like copy-paste every dependency. New git repository created.</p><p><u>Will build the app and log here simultaneously</u></p><p>Learning reactjs.</p>",
    "time": "25 October 2017",
    "tags": ["project", "language reference", "reactjs"]
  },
  {
    "title": "Project#18: Ionic Messenger",
    "content": "<p>As the name suggests, this is a hybrid app for both android and iOS using Ionic 3 framework. Ionic framework heavily depends on Angular framework and that's awesome for me. After installing cordova and ionic I went on to open package.json to see the versions of all the dependencies used. To my surprise Ionic 3 uses Angular 5! It was just released a month ago and they have a full support for Angular 5 already with all of it's modules updated to version 5. That was cool to see. Now I will have to learn the concepts introduced in Angular 5 as well.</p><p>The interface of this app will be simple for now because I will concentrate on implementing the backend features I have in my mind. The aim of this project is to demonstrate the obsecure but still useful features of a real time messaging app. The features I have in mind are as follows:<br><ul><li>Have a bot integration.</li><li>Send messages at a specific time set by you.</li><li>Bot to mimic as user. Auto pilot mode. Like sending \"yesterday's photos to a friend\" automatically when that friend asks.</li><li>Going private on click. Either of the user can ask the other to go private. In private mode messages will have constricted length and will get permanentally deleted after 5 seconds.</li></ul></p><p>These are the features I have in mind right now. I'm not sure if I will be able to implement the bot to mimic because there is not much data available for any particular user for the neural net to learn. I need large amount of structured data to train the neural net. Well, some features will be excluded and some will be included as I continue making the app. Will list all of them above.<br><u>Will build the app and log here simultaneously</u></p><h4><u>Day#1</u></h4><p>I've wireframed the app. It's very similar to your standard messaging app. Nothin fancy added there. The app created and <a target=\"_blank\" href='https://github.com/strcoder4007/ionic_messenger'><u>github repo</u></a> created.</p><p>Currently in the process of learning Ionic 3 Framework. Components in Angular is named simply Pages in Ionic. The design of the router is done keeping mobile in mind. Here the components/pages you add are stacked on top of other. Push and pop is done in order to navigate throug pages. Push and pop are available functions and the router is the same as stack of pages.</p><p>Started making the app. Started with coding a little frontend so that the backend can be tested later. The home page is done on the frontend part. No backend yet.</p><h4><u>Day#2</u></h4><p>populated the users with json placeholders. Placed the tab on top.</p><p>Made the chat page. Used AlertController and ActionSheetController for asking to go private and other options.</p><p>Tested for both android and iOS, both working fine.</p><p>I really like how data moves in Ionic. There are many ways for components/page to talk including the ones using Angular's service and eventemitters. Ionic has it's own way as well using navPrams. It's from the NavigationController, amazing!!! Angular should implement the same in their router module, that would make talking much easier.</p><p>Cleaned the app. Removed the dead code.</p><p>I just found out that I can test this app on my mobile in real-time and that too without any extra work. A duplicate server runs on the wifi network. That is such a brilliant idea. Mind = Blown.</p>",
    "time": "16 November 2017",
    "tags": ["project", "web dev", "angular", "ionic"]
  },
  {
    "title": "Project#19: Creek",
    "content": "<p>This is going to be a simple web app usable right out of the box. Writing this in typescript using angular5 and nodejs (yet again). This is one of those apps that I'm gonna use on daily basis, aiding me in keeping myself up to date with the new albums from the artists I love. Now, adding my favourite artists is not going to be done manually! Using last.fm api I will get all the artists I've listented to this far. This list will be full of artists which I don't want as well. Therefore, I will filter the artists whose atleast N songs I've listened. Where N can be set by the user depending on his/her needs. I'm setting it to 10 by default.</p><p>So, basically I want something where I could go and instantly get oncoming albums. I don't need to make any extra effort at all for this app to work. No artists to add, literally.</p><p><u>Will build the app and log here simultaneously</u></p><h4><u>Day#1</u></h4><p>Created the structure of the app. Added dependencies and committed to <a target=\"_blank\" href='https://github.com/strcoder4007/creek'><u>github</u></a></p><p>Started frontend. Will use the method I like better. Gonna make skeleton frontend for the backend to work. When the backend gets completed I will code the frontend. Also, right now I'm not able to come up with a good, fresh and clean frontend.</p>",
    "time": "25 November 2017",
    "tags": [
      "project",
      "web dev",
      "angular",
      "nodejs",
      "yet another nodejs app"
    ]
  }
]
